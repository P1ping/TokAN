import datetime as dt
import math

import torch
import torch.nn.functional as F

from tokan.utils import get_pylogger
from tokan.matcha.utils.model import (
    denormalize,
    fix_len_compatibility,
    generate_path,
    sequence_mask,
)

from tokan.matcha.models.components.flow_matching import CFM
from tokan.yirga.models.baselightningmodule import BaseLightningClass
from tokan.yirga.models.components.text_encoder import TextEncoder
from tokan.yirga.models.components.variance_predictor import get_duration_predictor
from tokan.yirga.utils.model import generate_even_path, scale_to_total_duration

log = get_pylogger(__name__)


class YirgaTokenToMel(BaseLightningClass):  # â˜•
    def __init__(
        self,
        n_vocab,
        spk_emb_dim,
        n_feats,
        encoder,
        decoder,
        cfm,
        data_statistics,
        optimizer=None,
        scheduler=None,
        upsample_rate=None,
        predict_duration=True,
        training_cfg_rate=0.2,
        inference_cfg_rate=2.0,
    ):
        super().__init__()

        self.save_hyperparameters(logger=False)

        self.n_vocab = n_vocab
        self.spk_emb_dim = spk_emb_dim
        self.n_feats = n_feats
        self.upsample_rate = upsample_rate
        self.predict_duration = predict_duration

        self.encoder = TextEncoder(
            encoder.encoder_type,
            encoder.encoder_params,
            n_vocab,
        )

        self.spk_embedder = torch.nn.Linear(spk_emb_dim, encoder.encoder_params.n_channels)

        self.duration_predictor = (
            get_duration_predictor(encoder.duration_predictor_params) if self.predict_duration else None
        )

        self.decoder = CFM(
            in_channels=encoder.encoder_params.n_channels + n_feats,
            out_channel=n_feats,
            cfm_params=cfm,
            decoder_params=decoder,
            spk_emb_dim=spk_emb_dim,
        )
        self.training_cfg_rate = training_cfg_rate
        self.inference_cfg_rate = inference_cfg_rate

        self.update_data_statistics(data_statistics)

    @torch.inference_mode()
    def synthesise(
        self,
        x,
        x_lengths,
        n_timesteps,
        temperature=1.0,
        spks=None,
        cond=None,
        total_duration=None,
        force_total_duration=True,
    ):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            temperature (float, optional): controls variance of terminal distribution.
            spks (bool, optional): speaker ids.
                shape: (batch_size,)
            total_duration (int, optional): the total duration values of samples.
            force_total_duration (bool, optional): whether to force the total duration to be the same as `total_duration`.
                only used when `total_duration` is not None.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
        """
        # For RTF computation
        t = dt.datetime.now()

        x, x_mask = self.encoder(x, x_lengths, spks)

        spk_embed = self.spk_embedder(spks)  # (B, D)
        x = x + spk_embed.unsqueeze(-1) * x_mask  # (B, D, T)

        if self.predict_duration:
            w = (
                self.duration_predictor(x, x_mask, total_duration=total_duration)
                if (total_duration is not None) and self.duration_predictor.support_total_duration
                else self.duration_predictor(x, x_mask)
            )
            w_ceil = (
                scale_to_total_duration(w, total_duration)
                if (total_duration is not None) and force_total_duration
                else self.duration_predictor.round_duration(w)
            )
            y_lengths = torch.clamp_min(torch.sum(w_ceil, [1, 2]), 1).long()
            y_max_length = y_lengths.max()
            y_max_length_ = fix_len_compatibility(y_max_length)
            # Use predicted durations `w_ceil` to generate the expansion map `attn`
            y_mask = sequence_mask(y_lengths, y_max_length_).unsqueeze(1).to(x_mask.dtype)
            attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
            attn = generate_path(w_ceil.squeeze(1), attn_mask.squeeze(1)).unsqueeze(1)
        else:
            y_lengths = torch.floor(x_lengths * self.upsample_rate).long()
            y_max_length = y_lengths.max()
            y_max_length_ = fix_len_compatibility(y_max_length)
            y_mask = sequence_mask(y_lengths, y_max_length_).unsqueeze(1).to(x_mask.dtype)
            attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
            attn = generate_even_path(self.upsample_rate, attn_mask.squeeze(1))

        # Expand encoded `x` and obtain `h_y`
        h_y = torch.matmul(attn.squeeze(1).transpose(1, 2), x.transpose(1, 2))
        h_y = h_y.transpose(1, 2)  # (B, D, T)

        encoder_outputs = h_y[:, :, :y_max_length]

        # Generate sample tracing the probability flow
        decoder_outputs = self.decoder(
            h_y, y_mask, n_timesteps, temperature, spks, cond, cfg_rate=self.inference_cfg_rate
        )
        decoder_outputs = decoder_outputs[:, :, :y_max_length]

        t = (dt.datetime.now() - t).total_seconds()
        rtf = t * 22050 / (decoder_outputs.shape[-1] * 256)

        return {
            "encoder_outputs": encoder_outputs,
            "decoder_outputs": decoder_outputs,
            "attn": attn[:, :, :, :y_max_length],
            "mel": denormalize(decoder_outputs, self.mel_mean, self.mel_std),
            "mel_lengths": y_lengths,
            "rtf": rtf,
        }

    def forward(self, x, x_lengths, y, y_lengths, spks=None, cond=None, durations=None):
        """
        Computes 3 losses:
            1. (optional) duration loss: loss between predicted token durations and those extracted by Monotinic Alignment Search (MAS).
            2. (optional) prior loss: loss between mel-spectrogram and encoder outputs.
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            y (torch.Tensor): batch of corresponding mel-spectrograms.
                shape: (batch_size, n_feats, max_mel_length)
            y_lengths (torch.Tensor): lengths of mel-spectrograms in batch.
                shape: (batch_size,)
            spks (torch.Tensor, optional): speaker ids.
                shape: (batch_size,)
        """
        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        x, x_mask = self.encoder(x, x_lengths, spks)

        spk_embed = self.spk_embedder(spks)  # (B, D)
        x = x + spk_embed.unsqueeze(-1) * x_mask  # (B, D, T)

        y_max_length = y.shape[-1]
        assert torch.allclose(x_lengths * self.upsample_rate, y_lengths.float(), 1.0)
        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)

        if self.predict_duration:
            # Compute deduplicating alignment from token-level durations
            x_dedup_lengths = durations.sum(dim=1).long()
            x_dedup_mask = sequence_mask(x_dedup_lengths, x_dedup_lengths.max()).unsqueeze(1).to(x_mask)
            attn_dedup_mask = x_mask.unsqueeze(-1) * x_dedup_mask.unsqueeze(2)
            attn_dedup = generate_path(durations.squeeze(1), attn_dedup_mask.squeeze(1))  # (B, T_x, T_y/k)

            # Compute frame-level alignment and durations
            attn = F.interpolate(attn_dedup.float(), scale_factor=self.upsample_rate, mode="nearest")  # (B, T_x, T_y)
            attn = F.pad(attn, (0, y_max_length - attn.size(-1)))
            # logw_ = torch.log(1e-8 + durations.unsqueeze(1) * self.upsample_rate) * x_mask
            w_ = torch.sum(attn.unsqueeze(1), -1) * x_mask
            dur_loss = self.duration_predictor.compute_loss(x.detach(), x_mask, w_)
        else:
            attn = generate_even_path(self.upsample_rate, attn_mask.squeeze(1))
            dur_loss = 0.0

        # Align encoded tokens with mel-spectrogram
        h_y = torch.matmul(attn.squeeze(1).transpose(1, 2), x.transpose(1, 2))
        h_y = h_y.transpose(1, 2)
        if self.training_cfg_rate > 0.0:
            cfg_mask = torch.rand(h_y.shape[0], device=h_y.device) > self.training_cfg_rate
            h_y = h_y * cfg_mask.view(-1, 1, 1)  # (B, D, T)
            spks = spks * cfg_mask.view(-1, 1)  # (B, D)
            cond = cond * cfg_mask.view(-1, 1, 1) if cond is not None else None

        # Compute loss of the decoder
        diff_loss, _ = self.decoder.compute_loss(x1=y, mask=y_mask, mu=h_y, spks=spks, cond=cond)

        return diff_loss, dur_loss, attn
